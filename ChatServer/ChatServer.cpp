#include <iostream>  
#include "windows.h" // Не забудьте включить заголовочный файл
#include "process.h"
#include <string>
using namespace std;
#pragma comment(lib, "WS2_32.lib")  // Отображение загрузки ws2_32.dll ws2_32.dll - последняя версия сокета

void Receive(void *param)		// Функция потока, принимающая данные
{
    while (true)
    {
        // Сервер принимает данные
        SOCKET revClientSocket = *(SOCKET*)(param);
        char recvbuf[2048] = {};		// Приемный буфер
        if (recv(revClientSocket, recvbuf, 2048, 0) == SOCKET_ERROR)
        {
            cout << "Не удалось принять данные!" << endl;
        }
        else
            cout << "[Клиент] сказал:" << recvbuf << endl;
    }
}

void Send(void *param)		// Функция потока для отправки данных
{
    while (1)
    {
        // Сервер отправляет данные
        SOCKET revClientSocket = *(SOCKET*)(param);
        char sendbuf[2048] = {};		// Отправляем буфер
        cin.getline(sendbuf, 2048);
        if (send(revClientSocket, sendbuf, strlen(sendbuf), 0) == SOCKET_ERROR)
        {
            cout << "Не удалось отправить сообщение!" << endl;
        }
        else
            cout << "[Я сказал:" << sendbuf << endl;
    }
}

int main(int argc, char* argv[])
{
	setlocale(LC_ALL, "rus");
    cout << "----------- сервер -----------" << endl;

	// Инициализация сокета
	WSADATA wsaData;	// Эта структура используется для хранения данных Windows Sockets, возвращаемых после вызова функции WSAStartup.
	WORD sockVersion = MAKEWORD(2, 2);	// Информация о номере версии библиотеки сетевого программирования Windows
	if (WSAStartup(sockVersion, &wsaData) != 0) // Функция WSAStartup предназначена для инициализации и загрузки сети Windows в программе
	{
		cout << "Ошибка инициализации сокета!" << endl;
		return 0;
	}

	// Создаем серверный сокет
	SOCKET SeverSocket;
	if ((SeverSocket = socket(AF_INET, SOCK_STREAM, 0)) == SOCKET_ERROR)
	{
		cout << "Не удалось создать сокет!" << endl;
		return 0;
	}
	struct sockaddr_in SeverAddress;		// Адрес привязки: есть IP-адрес, номер порта и семейство протоколов
	memset(&SeverAddress, 0, sizeof(sockaddr_in)); // Инициализируем структуру
	SeverAddress.sin_family = AF_INET;
	SeverAddress.sin_addr.S_un.S_addr = htonl(INADDR_ANY);// Заполняем локальный IP-адрес 
	SeverAddress.sin_port = htons(60000);// Устанавливаем номер порта

	// Привязать сокет Укажите привязанный IP-адрес и номер порта
	if (bind(SeverSocket, (sockaddr*)&SeverAddress, sizeof(SeverAddress)) == SOCKET_ERROR)
	{
		cout << "Не удалось привязать сокет!"<<endl;
		return 0;
	}

	// Мониторинг сервера	
	if (listen(SeverSocket, SOMAXCONN) == SOCKET_ERROR) // Второй параметр мониторинга: сколько клиентских запросов можно сохранить, что очень полезно для параллельного программирования.
	{
		cout << "Сбой мониторинга!"<<endl;
		return 0;
	}
	else
		cout << "Сервер слушает:"<<endl;

	// Сервер принимает запрос на подключение
	sockaddr_in revClientAddress;	// Адрес и порт сокета
	SOCKET revClientSocket = INVALID_SOCKET;		// Используется для получения клиентских подключений
	//memset(&revClientAddress, 0, sizeof(revClientAddress));
	int addlen = sizeof(revClientAddress);
	if ((revClientSocket = accept(SeverSocket, (sockaddr*)&revClientAddress, &addlen)) == INVALID_SOCKET)
	{
		cout << "Не удалось принять клиентское соединение!" << endl;
		return 0;
	}
	else
		cout << "Успешно принять клиентское соединение!"<<endl;

	// Создаем два дочерних потока
	_beginthread(Receive, 0, &revClientSocket);
	_beginthread(Send, 0, &revClientSocket);

	while (true) {}  // Чтобы предотвратить выход из основного потока, дочерний поток вынужден умереть, а основной поток входит в цикл

	// Закрываем сокет
	closesocket(revClientSocket);
	closesocket(SeverSocket);

	// завершение
	WSACleanup();
	cout << "Сервер остановлен!" << endl;
    
    return 0;
}
